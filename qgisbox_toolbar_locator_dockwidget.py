# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QgsBoxToolbarLocatorDockWidget
                                 A QGIS plugin
 Help locate the relevant toolbar buttons
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-08-27
        git sha              : $Format:%H$
        copyright            : (C) 2025 by hxbb00
        email                : hxbb00@qq.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt, QAbstractItemModel, QModelIndex

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'qgisbox_toolbar_locator_dockwidget_base.ui'))


class QgsBoxToolbarLocatorDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None, iface=None):
        """Constructor."""
        super(QgsBoxToolbarLocatorDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.iface = iface        

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
        
    def populateMenuAndToolbarData(self):
        """获取并显示所有菜单和工具栏按钮"""
        try:
            if not self.iface:
                self._show_error("无法访问QGIS接口")
                return
                
            # 获取主窗口
            main_window = self.iface.mainWindow()
            if not main_window:
                self._show_error("无法获取QGIS主窗口")
                return
                
            # 创建模型
            self.model = QtGui.QStandardItemModel()
            self.model.setHorizontalHeaderLabels(['菜单/工具栏项目'])
            
            # 添加菜单节点
            menus_root = QtGui.QStandardItem('菜单')
            self.model.appendRow(menus_root)
            # 收集所有菜单 - 直接传入主窗口实例，让_collectMenus方法使用menuBar()
            self._collectMenus(main_window, menus_root)
            
            # 添加工具栏节点
            toolbars_root = QtGui.QStandardItem('工具栏')
            self.model.appendRow(toolbars_root)
            self._collectToolbars(main_window, toolbars_root)
            
            # 设置模型到treeView
            self.treeView.setModel(self.model)
            
            # 设置TreeView属性以提高用户体验
            self.treeView.setAlternatingRowColors(True)
            self.treeView.setSortingEnabled(True)
            self.treeView.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
            self.treeView.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
            
            # 展开所有节点
            self.treeView.expandAll()
            
            # 自动调整列宽
            self.treeView.header().setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)
            
        except Exception as e:
            self._show_error(f"获取菜单和工具栏时出错: {str(e)}")
    
    def _show_error(self, message):
        """显示错误消息"""
        error_item = QtGui.QStandardItem(f"错误: {message}")
        error_item.setForeground(QtGui.QColor(255, 0, 0))  # 设置为红色
        
        self.model = QtGui.QStandardItemModel()
        self.model.setHorizontalHeaderLabels(['错误信息'])
        self.model.appendRow(error_item)
        self.treeView.setModel(self.model)
    
    def _collectMenus(self, main_window, parent_item):
        """使用menuBar()方法直接获取主菜单栏"""
        try:
            # 使用menuBar()方法直接获取主菜单栏
            menu_bar = main_window.menuBar()
            if menu_bar:
                # 获取菜单栏中的所有顶级菜单
                for action in menu_bar.actions():
                    menu = action.menu()
                    if menu:
                        title = menu.title()
                        if not title and action.text():
                            title = action.text()
                        
                        if title:  # 确保菜单有标题
                            menu_item = QtGui.QStandardItem(title)
                            font = menu_item.font()
                            font.setBold(True)
                            menu_item.setFont(font)
                            parent_item.appendRow(menu_item)
                            
                            # 递归收集子菜单和菜单项
                            self._collectMenuItems(menu, menu_item)
                
                # 如果没有找到菜单，添加提示
                if parent_item.rowCount() == 0:
                    no_menu_item = QtGui.QStandardItem("未找到菜单")
                    parent_item.appendRow(no_menu_item)
            else:
                no_menu_bar_item = QtGui.QStandardItem("未找到菜单栏")
                parent_item.appendRow(no_menu_bar_item)
        except Exception as e:
            # 如果收集过程中出错，添加错误信息但继续执行
            error_item = QtGui.QStandardItem(f"收集菜单时出错: {str(e)}")
            error_item.setForeground(QtGui.QColor(255, 165, 0))  # 设置为橙色
            parent_item.appendRow(error_item)
    
    def _collectMenuItems(self, menu, parent_item):
        """收集菜单项，优化对嵌套菜单和不同类型菜单项的处理"""
        try:
            # 添加菜单项计数信息
            action_count = len(menu.actions())
            if action_count > 0:
                # 优化菜单项的收集逻辑
                for action in menu.actions():
                    # 跳过分隔符
                    if action.isSeparator():
                        continue
                     
                    # 获取菜单项文本，优先使用text
                    text = action.text()
                    
                    # 如果text为空，尝试获取toolTip信息
                    if not text:
                        try:
                            tooltip = action.toolTip()
                            if tooltip:
                                # 截取toolTip的前50个字符作为显示文本
                                text = tooltip[:50] + "..." if len(tooltip) > 50 else tooltip
                                text = f"[提示] {text}"
                        except Exception:
                            pass
                    
                    # 如果还是没有文本，尝试获取其他信息
                    if not text:
                        if action.objectName():
                            text = f"({action.objectName()})"
                        else:
                            text = "无标题菜单项"
                    
                    # 移除快捷键标记和加速器符号
                    if '\t' in text:
                        text = text.split('\t')[0]
                    text = text.replace('&', '')
                    
                    # 创建菜单项
                    item = QtGui.QStandardItem(text)
                    
                    # 设置菜单项属性
                    if not action.isEnabled():
                        # 禁用的菜单项设置为灰色
                        item.setForeground(QtGui.QColor(160, 160, 160))
                    
                    # 检查是否有快捷键
                    shortcut = action.shortcut().toString()
                    if shortcut:
                        item.setToolTip(f"快捷键: {shortcut}")
                    
                    # 检查动作类型并设置状态信息
                    if action.isCheckable():
                        check_state = "已勾选" if action.isChecked() else "未勾选"
                        item.setToolTip(f"{item.toolTip()}\n状态: {check_state}" if item.toolTip() else f"状态: {check_state}")
                    
                    # 检查是否是子菜单
                    submenu = action.menu()
                    if submenu:
                        # 为子菜单设置特殊格式
                        font = item.font()
                        font.setBold(True)
                        item.setFont(font)
                        parent_item.appendRow(item)
                        # 递归收集子菜单
                        self._collectMenuItems(submenu, item)
                    else:
                        # 常规菜单项
                        parent_item.appendRow(item)
            else:
                # 如果菜单为空，添加提示
                empty_item = QtGui.QStandardItem("此菜单为空")
                empty_item.setForeground(QtGui.QColor(160, 160, 160))  # 设置为灰色
                parent_item.appendRow(empty_item)
        except Exception as e:
            # 如果收集过程中出错，添加错误信息但继续执行
            error_item = QtGui.QStandardItem(f"收集菜单项时出错: {str(e)}")
            error_item.setForeground(QtGui.QColor(255, 165, 0))  # 设置为橙色
            parent_item.appendRow(error_item)
    def _collectToolbars(self, main_window, parent_item):
        """收集所有工具栏，优化对工具栏名称的获取"""
        try:
            if not main_window:
                error_item = QtGui.QStandardItem("错误: 无效的主窗口引用")
                error_item.setForeground(QtGui.QColor(255, 165, 0))
                parent_item.appendRow(error_item)
                return
            
            try:
                toolbars = main_window.findChildren(QtWidgets.QToolBar)
                
                if not toolbars:
                    no_toolbar_item = QtGui.QStandardItem("未找到工具栏")
                    parent_item.appendRow(no_toolbar_item)
                    return
                    
                for toolbar in toolbars:
                    try:
                        # 安全获取工具栏名称（不变）
                        title = ""
                        try:
                            title = toolbar.windowTitle()
                            if not title:
                                title = toolbar.toolTip()
                                if not title:
                                    continue
                        except Exception as name_error:
                            title = f"工具栏(获取名称出错: {str(name_error)})"
                        
                        toolbar_item = QtGui.QStandardItem(title)
                        font = toolbar_item.font()
                        font.setBold(True)
                        font.setItalic(True)
                        toolbar_item.setFont(font)
                        parent_item.appendRow(toolbar_item)
                        
                        try:
                            actions = toolbar.actions()
                            action_count = 0
                            
                            for action in actions:
                                if action.isSeparator():
                                    continue
                                
                                try:
                                    action_text = ""
                                    # 1. 优先获取原始text（去重&符号）
                                    try:
                                        raw_text = action.text()
                                        if raw_text:
                                            action_text = raw_text
                                    except Exception:
                                        pass
                                    
                                    # 2. text为空时，尝试获取iconText（图标下方的短文本）
                                    if not action_text:
                                        try:
                                            icon_text = action.iconText()
                                            if icon_text:
                                                action_text = f"[图标文本] {icon_text}"
                                        except Exception:
                                            pass
                                    
                                    # 3. 仍为空，尝试tooltip（截取前50字符）
                                    if not action_text:
                                        try:
                                            tooltip = action.toolTip()
                                            if tooltip:
                                                action_text = f"[提示] {tooltip}"
                                        except Exception:
                                            pass
                                    
                                    # 4. 仍为空，尝试statusTip（状态栏提示）
                                    if not action_text:
                                        try:
                                            status_tip = action.statusTip()
                                            if status_tip:
                                                action_text = f"[状态提示] {status_tip}"
                                        except Exception:
                                            pass
                                    
                                    # 5. 仍为空，尝试whatsThis（详细说明）
                                    if not action_text:
                                        try:
                                            whats_this = action.whatsThis()
                                            if whats_this:
                                                action_text = f"[详细说明] {whats_this}"
                                        except Exception:
                                            pass
                                    
                                    # 6. 所有文本都为空，显示兜底信息（明确原因）
                                    if not action_text:
                                        if action.objectName():
                                            # 无图标但有对象名
                                            action_text = f"({action.objectName()}) 无文本/提示"
                                        elif action.icon():
                                            # 有图标但无任何文本
                                            action_text = "[纯图标按钮] 无文本/提示"
                                        else:
                                            # 完全无信息
                                            action_text = "无标题/无图标/无提示"
                                    
                                    # 创建item并设置样式（不变）
                                    item = QtGui.QStandardItem(action_text)
                                    
                                    # 检查是否禁用（不变）
                                    try:
                                        if not action.isEnabled():
                                            item.setForeground(QtGui.QColor(160, 160, 160))
                                    except Exception:
                                        pass
                                    
                                    # 检查快捷键（不变）
                                    try:
                                        shortcut = action.shortcut().toString()
                                        if shortcut:
                                            item.setToolTip(f"快捷键: {shortcut}")
                                    except Exception:
                                        pass
                                    
                                    toolbar_item.appendRow(item)
                                    action_count += 1
                                except Exception as text_error:
                                    item = QtGui.QStandardItem(f"(按钮处理出错: {str(text_error)})")
                                    item.setForeground(QtGui.QColor(255, 165, 0))
                                    toolbar_item.appendRow(item)
                            
                            if action_count == 0:
                                empty_item = QtGui.QStandardItem("(空工具栏)")
                                empty_item.setForeground(QtGui.QColor(128, 128, 128))
                                toolbar_item.appendRow(empty_item)
                        except Exception as actions_error:
                            error_item = QtGui.QStandardItem(f"获取工具栏动作时出错: {str(actions_error)}")
                            error_item.setForeground(QtGui.QColor(255, 165, 0))
                            toolbar_item.appendRow(error_item)
                    except Exception as toolbar_error:
                        error_item = QtGui.QStandardItem(f"处理工具栏时出错: {str(toolbar_error)}")
                        error_item.setForeground(QtGui.QColor(255, 165, 0))
                        parent_item.appendRow(error_item)
            except Exception as find_error:
                error_item = QtGui.QStandardItem(f"查找工具栏时出错: {str(find_error)}")
                error_item.setForeground(QtGui.QColor(255, 165, 0))
                parent_item.appendRow(error_item)
        except Exception as e:
            error_item = QtGui.QStandardItem(f"收集工具栏时出错: {str(e)}")
            error_item.setForeground(QtGui.QColor(255, 165, 0))
            parent_item.appendRow(error_item)
