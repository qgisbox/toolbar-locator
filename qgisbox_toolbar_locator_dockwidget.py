# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QgsBoxToolbarLocatorDockWidget
                                 A QGIS plugin
 Help locate the relevant toolbar buttons
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-08-27
        git sha              : $Format:%H$
        copyright            : (C) 2025 by hxbb00
        email                : hxbb00@qq.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt, QAbstractItemModel, QModelIndex, QSortFilterProxyModel

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'qgisbox_toolbar_locator_dockwidget_base.ui'))


class QgsBoxToolbarLocatorDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None, iface=None):
        """Constructor."""
        super(QgsBoxToolbarLocatorDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.iface = iface        
        # 连接TreeView的doubleClicked信号到闪烁功能
        self.treeView.doubleClicked.connect(self._onItemDoubleClicked)
        
        # 初始化搜索功能
        self._initSearch()

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
        
    def populateMenuAndToolbarData(self):
        """获取并显示所有菜单和工具栏按钮"""
        try:
            if not self.iface:
                self._show_error("无法访问QGIS接口")
                return
                
            # 获取主窗口
            main_window = self.iface.mainWindow()
            if not main_window:
                self._show_error("无法获取QGIS主窗口")
                return
                
            # 创建模型
            self.model = QtGui.QStandardItemModel()
            self.model.setHorizontalHeaderLabels(['菜单/工具栏项目'])
            
            # 添加菜单节点
            menus_root = QtGui.QStandardItem('菜单')
            self.model.appendRow(menus_root)
            # 收集所有菜单 - 直接传入主窗口实例，让_collectMenus方法使用menuBar()
            self._collectMenus(main_window, menus_root)
            
            # 添加工具栏节点
            toolbars_root = QtGui.QStandardItem('工具栏')
            self.model.appendRow(toolbars_root)
            self._collectToolbars(main_window, toolbars_root)
            
            # 设置代理模型
            self.proxy_model.setSourceModel(self.model)
            self.treeView.setModel(self.proxy_model)
            
            # 设置TreeView属性以提高用户体验
            self.treeView.setAlternatingRowColors(True)
            self.treeView.setSortingEnabled(True)
            self.treeView.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
            self.treeView.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
            
            # 展开所有节点
            self.treeView.expandAll()
            
            # 自动调整列宽
            self.treeView.header().setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)
            
        except Exception as e:
            self._show_error(f"获取菜单和工具栏时出错: {str(e)}")
    
    def _show_error(self, message):
        """显示错误消息"""
        error_item = QtGui.QStandardItem(f"错误: {message}")
        error_item.setForeground(QtGui.QColor(255, 0, 0))  # 设置为红色
        
        self.model = QtGui.QStandardItemModel()
        self.model.setHorizontalHeaderLabels(['错误信息'])
        self.model.appendRow(error_item)
        if hasattr(self, 'proxy_model'):
            self.proxy_model.setSourceModel(self.model)
            self.treeView.setModel(self.proxy_model)
        else:
            self.treeView.setModel(self.model)
    
    def _onItemDoubleClicked(self, index):
        """处理TreeView中项目的双击事件，触发对应的action闪烁"""
        try:
            # 如果使用了代理模型，需要转换索引
            if hasattr(self, 'proxy_model'):
                index = self.proxy_model.mapToSource(index)
                
            # 获取双击的item
            item = self.model.itemFromIndex(index)
            if not item:
                return
                
            # 从item的data中获取action对象
            action = item.data()
            if not action:
                return
                
            # 调用闪烁功能
            self._flashAction(action)
        except Exception as e:
            # 如果出错，不影响其他功能
            print(f"双击处理出错: {str(e)}")
    
    def _initSearch(self):
        """初始化搜索功能"""
        # 创建并设置搜索代理模型
        self.proxy_model = QSortFilterProxyModel()
        self.proxy_model.setFilterCaseSensitivity(Qt.CaseInsensitive)  # 不区分大小写
        self.proxy_model.setRecursiveFilteringEnabled(True)  # 递归过滤子项
        self.proxy_model.setFilterKeyColumn(0)  # 只过滤第一列
        
        # 连接lineEdit的textChanged信号到搜索功能
        self.lineEdit.textChanged.connect(self._onSearchTextChanged)
    
    def _onSearchTextChanged(self, text):
        """处理搜索文本变化事件，过滤treeView内容"""
        try:
            self.proxy_model.setFilterFixedString(text)
        except Exception as e:
            print(f"搜索时出错: {str(e)}")
    
    def _flashAction(self, action):
        """使与action关联的所有widgets（按钮、菜单项等）闪烁"""
        try:
            from qgis.PyQt.QtCore import QTimer, QTime
            
            # 获取与action关联的所有widgets
            widgets = action.associatedWidgets()
            if not widgets:
                return
                
            # 保存原始样式表
            original_styles = []
            for widget in widgets:
                original_styles.append((widget, widget.styleSheet()))
            
            # 闪烁次数和间隔
            flash_count = 0
            max_flashes = 3  # 闪烁3次
            flash_interval = 200  # 200毫秒间隔
            
            # 创建定时器
            timer = QTimer()
            timer.setSingleShot(False)
            
            def flash():
                nonlocal flash_count
                flash_count += 1
                
                for widget, original_style in original_styles:
                    if flash_count % 2 == 1:
                        # 奇数闪烁 - 高亮显示
                        widget.setStyleSheet("background-color: yellow; color: black;")
                    else:
                        # 偶数闪烁 - 恢复原始样式
                        widget.setStyleSheet(original_style)
                
                if flash_count >= max_flashes * 2:
                    # 闪烁完成，恢复所有样式并停止定时器
                    for widget, original_style in original_styles:
                        widget.setStyleSheet(original_style)
                    timer.stop()
            
            # 连接定时器信号并启动
            timer.timeout.connect(flash)
            timer.start(flash_interval)
            
        except Exception as e:
            print(f"闪烁action时出错: {str(e)}")
    
    def _collectMenus(self, main_window, parent_item):
        """使用menuBar()方法直接获取主菜单栏"""
        try:
            # 使用menuBar()方法直接获取主菜单栏
            menu_bar = main_window.menuBar()
            if menu_bar:
                # 获取菜单栏中的所有顶级菜单
                for action in menu_bar.actions():
                    menu = action.menu()
                    if menu:
                        title = menu.title()
                        if not title and action.text():
                            title = action.text()
                        
                        if title:  # 确保菜单有标题
                            menu_item = QtGui.QStandardItem(title)
                            font = menu_item.font()
                            font.setBold(True)
                            menu_item.setFont(font)
                            parent_item.appendRow(menu_item)
                            
                            # 递归收集子菜单和菜单项
                            self._collectMenuItems(menu, menu_item)
                
                # 如果没有找到菜单，添加提示
                if parent_item.rowCount() == 0:
                    no_menu_item = QtGui.QStandardItem("未找到菜单")
                    parent_item.appendRow(no_menu_item)
            else:
                no_menu_bar_item = QtGui.QStandardItem("未找到菜单栏")
                parent_item.appendRow(no_menu_bar_item)
        except Exception as e:
            # 如果收集过程中出错，添加错误信息但继续执行
            error_item = QtGui.QStandardItem(f"收集菜单时出错: {str(e)}")
            error_item.setForeground(QtGui.QColor(255, 165, 0))  # 设置为橙色
            parent_item.appendRow(error_item)
    
    def _collectMenuItems(self, menu, parent_item):
        """收集菜单项，优化对嵌套菜单和不同类型菜单项的处理"""
        try:
            # 添加菜单项计数信息
            action_count = len(menu.actions())
            if action_count > 0:
                # 优化菜单项的收集逻辑
                for action in menu.actions():
                    # 跳过分隔符
                    if action.isSeparator():
                        continue
                     
                    # 获取菜单项文本，优先使用text
                    text = action.text()
                    
                    # 如果text为空，尝试获取toolTip信息
                    if not text:
                        try:
                            tooltip = action.toolTip()
                            if tooltip:
                                # 截取toolTip的前50个字符作为显示文本
                                text = tooltip[:50] + "..." if len(tooltip) > 50 else tooltip
                                text = f"[提示] {text}"
                        except Exception:
                            pass
                    
                    # 如果还是没有文本，尝试获取其他信息
                    if not text:
                        if action.objectName():
                            text = f"({action.objectName()})"
                        else:
                            text = "<无标题菜单项>"
                    
                    # 移除快捷键标记和加速器符号
                    if '\t' in text:
                        text = text.split('\t')[0]
                    text = text.replace('&', '')
                    
                    # 创建菜单项
                    item = QtGui.QStandardItem(text)
                    
                    # 存储action对象到item的data中，用于双击操作
                    item.setData(action)
                    item.setToolTip(action.toolTip())
                    
                    # 设置菜单项属性
                    if not action.isEnabled():
                        # 禁用的菜单项设置为灰色
                        item.setForeground(QtGui.QColor(160, 160, 160))
                    
                    # 检查是否是子菜单
                    submenu = action.menu()
                    if submenu:
                        # 为子菜单设置特殊格式
                        font = item.font()
                        font.setBold(True)
                        item.setFont(font)
                        parent_item.appendRow(item)
                        # 递归收集子菜单
                        self._collectMenuItems(submenu, item)
                    else:
                        # 常规菜单项
                        parent_item.appendRow(item)
            else:
                # 如果菜单为空，添加提示
                empty_item = QtGui.QStandardItem("<此菜单为空>")
                empty_item.setForeground(QtGui.QColor(160, 160, 160))  # 设置为灰色
                parent_item.appendRow(empty_item)
        except Exception as e:
            # 如果收集过程中出错，添加错误信息但继续执行
            error_item = QtGui.QStandardItem(f"收集菜单项时出错: {str(e)}")
            error_item.setForeground(QtGui.QColor(255, 165, 0))  # 设置为橙色
            parent_item.appendRow(error_item)
    def _collectToolbars(self, main_window, parent_item):
        """收集所有工具栏，优化对工具栏名称的获取"""
        try:
            if not main_window:
                error_item = QtGui.QStandardItem("错误: 无效的主窗口引用")
                error_item.setForeground(QtGui.QColor(255, 165, 0))
                parent_item.appendRow(error_item)
                return
            
            try:
                toolbars = main_window.findChildren(QtWidgets.QToolBar)
                
                if not toolbars:
                    no_toolbar_item = QtGui.QStandardItem("未找到工具栏")
                    parent_item.appendRow(no_toolbar_item)
                    return
                    
                for toolbar in toolbars:
                    try:
                        # 安全获取工具栏名称（不变）
                        title = ""
                        try:
                            title = toolbar.windowTitle()
                            if not title:
                                title = toolbar.toolTip()
                                if not title:
                                    continue
                        except Exception as name_error:
                            title = f"工具栏(获取名称出错: {str(name_error)})"
                        
                        toolbar_item = QtGui.QStandardItem(title)
                        font = toolbar_item.font()
                        font.setBold(True)
                        font.setItalic(True)
                        toolbar_item.setFont(font)
                        parent_item.appendRow(toolbar_item)
                        
                        try:
                            toolbar_widgets = toolbar.findChildren(QtWidgets.QToolButton)
                            action_count = 0

                            for idx, widget in enumerate(toolbar_widgets):  # 添加索引，便于定位出错控件
                                try:
                                    # 处理场景1：QToolButton的默认Action（直接关联或自动生成）
                                    action = widget.defaultAction()
                                    if action:
                                        # 跳过分隔符和空文本Action
                                        if not action.isSeparator() and action.text().strip():
                                            item = QtGui.QStandardItem(f"{action.text()}")
                                            item.setData(action)
                                            item.setToolTip(action.toolTip())
                                            toolbar_item.appendRow(item)
                                            action_count += 1
                                        
                                            # 关键修复：检查Action是否绑定了菜单（自动生成按钮的场景）
                                            action_menu = action.menu()
                                            if action_menu and len(action_menu.actions()) > 0:
                                                self._collectMenuItems(action_menu, item)
                                            else:
                                                # 处理场景2：QToolButton直接绑定的菜单（手动添加的QToolButton）
                                                tb_menu = widget.menu()
                                                if tb_menu and not action_menu and len(tb_menu.actions()) > 0:  # 避免与Action的菜单重复处理
                                                    self._collectMenuItems(tb_menu, item)

                                
                                except Exception as widget_error:
                                    # 增强错误信息：包含控件索引、对象名，便于调试
                                    error_msg = f"处理工具栏按钮（索引{idx}，对象名：{widget.objectName() or '无'}）时出错: {str(widget_error)}"
                                    error_item = QtGui.QStandardItem(error_msg)
                                    error_item.setForeground(QtGui.QColor(255, 165, 0))
                                    toolbar_item.appendRow(error_item)
                            if action_count == 0:
                                no_action_item = QtGui.QStandardItem("此工具栏为空")
                                no_action_item.setForeground(QtGui.QColor(160, 160, 160))
                                toolbar_item.appendRow(no_action_item)

                        except Exception as actions_error:
                            error_item = QtGui.QStandardItem(f"获取工具栏动作时出错: {str(actions_error)}")
                            error_item.setForeground(QtGui.QColor(255, 165, 0))
                            toolbar_item.appendRow(error_item)
                    except Exception as toolbar_error:
                        error_item = QtGui.QStandardItem(f"处理工具栏时出错: {str(toolbar_error)}")
                        error_item.setForeground(QtGui.QColor(255, 165, 0))
                        parent_item.appendRow(error_item)
            except Exception as find_error:
                error_item = QtGui.QStandardItem(f"查找工具栏时出错: {str(find_error)}")
                error_item.setForeground(QtGui.QColor(255, 165, 0))
                parent_item.appendRow(error_item)
        except Exception as e:
            error_item = QtGui.QStandardItem(f"收集工具栏时出错: {str(e)}")
            error_item.setForeground(QtGui.QColor(255, 165, 0))
            parent_item.appendRow(error_item)
